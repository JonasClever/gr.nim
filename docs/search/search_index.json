{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gr.nim This is a plotting library for the Nim programming language. It is based on the GR framework . Pre-requisites You need to have Nim obviously and the GR framework installed on your system. Installing gr.nim Just do: nimble install https://github.com/mantielero/gr.nim About GR Framework GR framework includes several libraries: GR: this library provides many functions to make easier the creation of plots. Like creating axis, grid, \u2026 GR3: this library enables creating 3D animations. GRM: this library provides an easy interface in order to create plots with minimum boilerplate.","title":"Purpose"},{"location":"#grnim","text":"This is a plotting library for the Nim programming language. It is based on the GR framework .","title":"Gr.nim"},{"location":"#pre-requisites","text":"You need to have Nim obviously and the GR framework installed on your system.","title":"Pre-requisites"},{"location":"#installing-grnim","text":"Just do: nimble install https://github.com/mantielero/gr.nim","title":"Installing gr.nim"},{"location":"#about-gr-framework","text":"GR framework includes several libraries: GR: this library provides many functions to make easier the creation of plots. Like creating axis, grid, \u2026 GR3: this library enables creating 3D animations. GRM: this library provides an easy interface in order to create plots with minimum boilerplate.","title":"About GR Framework"},{"location":"benchmark/","text":"Long story short The performance is really good. In my laptop with an Intel(R) Core(TM) i7-4770HQ, I get: Nim+GR: 1088fps Python+GR: 387fps Python + Matplotlib: 46fps Code Nim+Gr import gr import times , math , sugar , sequtils # os let tstart = cpuTime () let x = linRange ( 0.0 , 2.0 * PI , 629 ) for i in 1 .. 2000 : let y = x . map ( x => sin ( x + i . float / 10.0 )) gr_clearws () plot ( x , y ) #sleep(1) let fps_gr = int ( 200.0 / ( cpuTime () - tstart )) echo \"fps (GR): \" , fps_gr and compiled like: $ nim c -d:release -d:danger bench.nim Python + GR and Python + Matplotlib from numpy import arange , sin , pi from time import time , sleep import os os . environ [ \"GKS_WSTYPE\" ] = \"gksqt\" num_frames = 2000 x = arange ( 0 , 2 * pi , 0.01 ) # create an animation using GR from gr.pygr import plot tstart = time () for i in range ( num_frames ): plot ( x , sin ( x + i / 10.0 )) sleep ( 0.0001 ) fps_gr = int ( num_frames / ( time () - tstart )) print ( 'fps (GR): %4d ' % fps_gr ) # create the same animation using matplotlib from matplotlib.pyplot import plot , draw , pause tstart = time () line , = plot ( x , sin ( x )) for i in range ( num_frames ): line . set_ydata ( sin ( x + i / 10.0 )) draw () pause ( 0.0001 ) fps_mpl = int ( num_frames / ( time () - tstart )) print ( 'fps (mpl): %4d ' % fps_mpl ) print ( ' speedup: %6.1f ' % ( float ( fps_gr ) / fps_mpl ))","title":"Benchmark"},{"location":"benchmark/#long-story-short","text":"The performance is really good. In my laptop with an Intel(R) Core(TM) i7-4770HQ, I get: Nim+GR: 1088fps Python+GR: 387fps Python + Matplotlib: 46fps","title":"Long story short"},{"location":"benchmark/#code","text":"","title":"Code"},{"location":"benchmark/#nimgr","text":"import gr import times , math , sugar , sequtils # os let tstart = cpuTime () let x = linRange ( 0.0 , 2.0 * PI , 629 ) for i in 1 .. 2000 : let y = x . map ( x => sin ( x + i . float / 10.0 )) gr_clearws () plot ( x , y ) #sleep(1) let fps_gr = int ( 200.0 / ( cpuTime () - tstart )) echo \"fps (GR): \" , fps_gr and compiled like: $ nim c -d:release -d:danger bench.nim","title":"Nim+Gr"},{"location":"benchmark/#python-gr-and-python-matplotlib","text":"from numpy import arange , sin , pi from time import time , sleep import os os . environ [ \"GKS_WSTYPE\" ] = \"gksqt\" num_frames = 2000 x = arange ( 0 , 2 * pi , 0.01 ) # create an animation using GR from gr.pygr import plot tstart = time () for i in range ( num_frames ): plot ( x , sin ( x + i / 10.0 )) sleep ( 0.0001 ) fps_gr = int ( num_frames / ( time () - tstart )) print ( 'fps (GR): %4d ' % fps_gr ) # create the same animation using matplotlib from matplotlib.pyplot import plot , draw , pause tstart = time () line , = plot ( x , sin ( x )) for i in range ( num_frames ): line . set_ydata ( sin ( x + i / 10.0 )) draw () pause ( 0.0001 ) fps_mpl = int ( num_frames / ( time () - tstart )) print ( 'fps (mpl): %4d ' % fps_mpl ) print ( ' speedup: %6.1f ' % ( float ( fps_gr ) / fps_mpl ))","title":"Python + GR and Python + Matplotlib"},{"location":"contour/","text":"Contour The following code: import gr import math , random # Create x, y, z sequences with 100 items let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) # Create the plot (a 1 liner) contour ( x , y , z ) # Wait for a key press discard readLine ( stdin ) # Cleaning grm_finalize () creates the following window:","title":"Contour"},{"location":"contour/#contour","text":"The following code: import gr import math , random # Create x, y, z sequences with 100 items let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) # Create the plot (a 1 liner) contour ( x , y , z ) # Wait for a key press discard readLine ( stdin ) # Cleaning grm_finalize () creates the following window:","title":"Contour"},{"location":"contourf/","text":"Contourf The following code: import gr import math , random # Create x, y, z sequences with 100 items let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) # Create the plot (a 1 liner) contourf ( x , y , z ) # Wait for a key press discard readLine ( stdin ) # Cleaning grm_finalize () creates the following window: Note Just by replacing contour into contourf","title":"Contourf"},{"location":"contourf/#contourf","text":"The following code: import gr import math , random # Create x, y, z sequences with 100 items let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) # Create the plot (a 1 liner) contourf ( x , y , z ) # Wait for a key press discard readLine ( stdin ) # Cleaning grm_finalize () creates the following window: Note Just by replacing contour into contourf","title":"Contourf"},{"location":"heatmap/","text":"Heatmap Danger This is not working properlly (due to GRM itself) The following code: import gr import math , random # Create x, y, z sequences with 100 items let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) # Create the plot (a 1 liner) heatmap ( x , y , z ) # Wait for a key press discard readLine ( stdin ) # Cleaning grm_finalize () creates the following window: Note Just by replacing contour by heatmap","title":"Heatmap"},{"location":"heatmap/#heatmap","text":"Danger This is not working properlly (due to GRM itself) The following code: import gr import math , random # Create x, y, z sequences with 100 items let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) # Create the plot (a 1 liner) heatmap ( x , y , z ) # Wait for a key press discard readLine ( stdin ) # Cleaning grm_finalize () creates the following window: Note Just by replacing contour by heatmap","title":"Heatmap"},{"location":"hexbin/","text":"Hexbin The following code: import gr import math , random let n = 100000 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = rand ( 1.0 ) y [ i ] = rand ( 1.0 ) hexbin ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Hexbin"},{"location":"hexbin/#hexbin","text":"The following code: import gr import math , random let n = 100000 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = rand ( 1.0 ) y [ i ] = rand ( 1.0 ) hexbin ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Hexbin"},{"location":"histogram/","text":"Histogram Danger Not working: invalid range GKS: Possible loss of precision in routine SET_WINDOW GKS: Rectangle definition is invalid in routine SET_WINDOW origin outside current window The following code: import gr import math , random let n = 100000 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = rand ( 1.0 ) y [ i ] = rand ( 1.0 ) hexbin ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Histogram"},{"location":"histogram/#histogram","text":"Danger Not working: invalid range GKS: Possible loss of precision in routine SET_WINDOW GKS: Rectangle definition is invalid in routine SET_WINDOW origin outside current window The following code: import gr import math , random let n = 100000 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = rand ( 1.0 ) y [ i ] = rand ( 1.0 ) hexbin ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Histogram"},{"location":"plot/","text":"Plot This function does not depend on GRM. It makes easy plotting data into a file instead of into a window. For example: import gr let ds1 = Dataset ( x : @[ 0.0 , 0.2 , 0.4 , 0.6 , 0.8 , 1.0 ] , y : @[ 0.3 , 0.5 , 0.4 , 0.2 , 0.6 , 0.7 ] ) let ds2 = Dataset ( x : @[- 0.3 , 0.2 , 0.35 , 0.6 , 0.8 , 0.85 ] , y : @[ 0.2 , 0.8 , - 0.4 , 0.4 , 2.4 , 1.3 ] ) plot ( @[ ds1 , ds2 ] , \"example.png\" ) plot ( @[ ds1 , ds2 ] , \"example.svg\" ) creates: example.png example.svg","title":"plot file"},{"location":"plot/#plot","text":"This function does not depend on GRM. It makes easy plotting data into a file instead of into a window. For example: import gr let ds1 = Dataset ( x : @[ 0.0 , 0.2 , 0.4 , 0.6 , 0.8 , 1.0 ] , y : @[ 0.3 , 0.5 , 0.4 , 0.2 , 0.6 , 0.7 ] ) let ds2 = Dataset ( x : @[- 0.3 , 0.2 , 0.35 , 0.6 , 0.8 , 0.85 ] , y : @[ 0.2 , 0.8 , - 0.4 , 0.4 , 2.4 , 1.3 ] ) plot ( @[ ds1 , ds2 ] , \"example.png\" ) plot ( @[ ds1 , ds2 ] , \"example.svg\" ) creates:","title":"Plot"},{"location":"plot/#examplepng","text":"","title":"example.png"},{"location":"plot/#examplesvg","text":"","title":"example.svg"},{"location":"plot2/","text":"Plot2 The following code: import gr import sequtils , sugar , math let x = linRange ( - 2.0 , 2.0 , 40 ) let y = x . map ( x => x ^ 3 + x ^ 2 + x ) plot2 ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window: Note Why plot2 ? Well I have created another plot function which does not depend on GRM and they share the same API.","title":"Plot2"},{"location":"plot2/#plot2","text":"The following code: import gr import sequtils , sugar , math let x = linRange ( - 2.0 , 2.0 , 40 ) let y = x . map ( x => x ^ 3 + x ^ 2 + x ) plot2 ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window: Note Why plot2 ? Well I have created another plot function which does not depend on GRM and they share the same API.","title":"Plot2"},{"location":"plot3/","text":"Plot3 The following code: import gr import sequtils , sugar , math let x = linRange ( 0.0 , 30.0 , 1000 ) let y = x . map ( x => cos ( x ) * x ) let z = x . map ( x => sin ( x ) * x ) plot3 ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Plot3"},{"location":"plot3/#plot3","text":"The following code: import gr import sequtils , sugar , math let x = linRange ( 0.0 , 30.0 , 1000 ) let y = x . map ( x => cos ( x ) * x ) let z = x . map ( x => sin ( x ) * x ) plot3 ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Plot3"},{"location":"scatter2d/","text":"Scatter The following code: import gr import sequtils , sugar , math let x = linRange ( - 2.0 , 2.0 , 40 ) let y = x . map ( x => 0.2 * x + 0.4 ) scatter ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Scatter"},{"location":"scatter2d/#scatter","text":"The following code: import gr import sequtils , sugar , math let x = linRange ( - 2.0 , 2.0 , 40 ) let y = x . map ( x => 0.2 * x + 0.4 ) scatter ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Scatter"},{"location":"scatter4d/","text":"Scatter Danger The size is not working. The following code: import gr import sequtils , sugar , math let x = linRange ( 0.0 , 1.0 , 11 ) let y = linRange ( 0.0 , 1.0 , 11 ) let s = linRange ( 50.0 , 400.0 , 11 ) let c = linRange ( 0.0 , 255.0 , 11 ) scatter ( x , y , s , c ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Scatter"},{"location":"scatter4d/#scatter","text":"Danger The size is not working. The following code: import gr import sequtils , sugar , math let x = linRange ( 0.0 , 1.0 , 11 ) let y = linRange ( 0.0 , 1.0 , 11 ) let s = linRange ( 50.0 , 400.0 , 11 ) let c = linRange ( 0.0 , 255.0 , 11 ) scatter ( x , y , s , c ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Scatter"},{"location":"status/","text":"Status This library is in infancy. I am not a proffessional developer so you should expect problems, and poor programming habits. I am a newbie in Nim by the way. Danger This library could bite your hand. Take it as it is.","title":"Status"},{"location":"status/#status","text":"This library is in infancy. I am not a proffessional developer so you should expect problems, and poor programming habits. I am a newbie in Nim by the way. Danger This library could bite your hand. Take it as it is.","title":"Status"},{"location":"stem/","text":"Stem The following code: import gr import sequtils , sugar , math let x = linRange ( - 2.0 , 2.0 , 40 ) let y = x . map ( x => x ^ 3 + x ^ 2 + x ) stem ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Stem"},{"location":"stem/#stem","text":"The following code: import gr import sequtils , sugar , math let x = linRange ( - 2.0 , 2.0 , 40 ) let y = x . map ( x => x ^ 3 + x ^ 2 + x ) stem ( x , y ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Stem"},{"location":"surface/","text":"Surface The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) surface ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Surface"},{"location":"surface/#surface","text":"The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) surface ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Surface"},{"location":"todo/","text":"TODO The main things to do from here: GRM Some of the functions are not working as they should. This library is moving fast, so the API can eventually break. Keep up to date with the newest API. Currently GR v0.48. GR3 There is no sugar for this API: [ ] To enable using Nim types instead of the types used in the bindings [ ] To make easier creating animations. GR To do something like GRM: [ ] Right now it is not easy to create plots. GR is not very well documented.","title":"TODO"},{"location":"todo/#todo","text":"The main things to do from here:","title":"TODO"},{"location":"todo/#grm","text":"Some of the functions are not working as they should. This library is moving fast, so the API can eventually break. Keep up to date with the newest API. Currently GR v0.48.","title":"GRM"},{"location":"todo/#gr3","text":"There is no sugar for this API: [ ] To enable using Nim types instead of the types used in the bindings [ ] To make easier creating animations.","title":"GR3"},{"location":"todo/#gr","text":"To do something like GRM: [ ] Right now it is not easy to create plots. GR is not very well documented.","title":"GR"},{"location":"tricont/","text":"Tri_cont The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) tri_cont ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Tri_cont"},{"location":"tricont/#tri_cont","text":"The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) tri_cont ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Tri_cont"},{"location":"trisurf/","text":"Tri_surf The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) trisurf ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Tri_surf"},{"location":"trisurf/#tri_surf","text":"The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) trisurf ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Tri_surf"},{"location":"wireframe/","text":"Wireframe The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) wireframe ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Wireframe"},{"location":"wireframe/#wireframe","text":"The following code: import gr import sequtils , sugar , math , random let n = 100 var x = newSeq [ float ] ( n ) var y = newSeq [ float ] ( n ) var z = newSeq [ float ] ( n ) for i in 0 .. < n : x [ i ] = 8.0 * rand ( 1.0 ) - 4.0 y [ i ] = 8.0 * rand ( 1.0 ) - 4.0 z [ i ] = sin ( x [ i ] ) + cos ( y [ i ] ) wireframe ( x , y , z ) discard readLine ( stdin ) grm_finalize () creates the following window:","title":"Wireframe"}]}